---
title: "Integrating proteomics data"
author: "Pratheepa Jeganathan, Susan Holmes"
date: '`r format(Sys.time(), "%d %B, %Y")`'
output: 
  BiocStyle::html_document
params:
  sample_id: 3
---

- Wagner 2018 Cytof
  - 140 breast cancer patients; Of 140, 6 tripple negative (TN)
  - cd45_sce_dropna$Clinical.Subtype == "TN"
  - 3 cancer-free
  - 73 protein markers in immune-centric and tumor-centric microenvironment
  
- Keren 2018 Multiplex Ion Bean Imaging (MIBI)
  - Tumor-immune microenvironment in TN patients
  - 41 TN patients
  - 36 proteins
  
We will choose patients with TN and immune group in both CyTOF and MIBI for the integrative analysis.

This workflow is for exploratory analysis of CyTOF and MIBI.


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
  message = FALSE,
  warning = FALSE,
  fig.width = 12,
  fig.height = 10)
```


```{r}
#library(flowCore)
library(SingleCellExperiment)
library(ggplot2)
# library(rstan)
#library(scater)
library(plyr)
library(reshape2)
library(readr)
#library(CATALYST)
library(magrittr)
#library(scMerge)
library(MultiAssayExperiment)
library(dplyr)
library(DESeq2)
library(abind)
library(tibble)
library(RColorBrewer)

library(igraph)

library(spdep)
library(stars)
library(stringr)

library(pheatmap)

library(raster)

library(uwot)# UMAP
library(scattermore)# to visualize more points
library(ggthemes)# colors

library(gstat)# variogram
library(sp)
```


# Mass-Tag CyTOF Breast Cancer Data

- For this analysis we use **cd45.sce**: CD45+ cells from the live cells; downsampled to 426,872 cells (assayed on immune panel) $\times$ 35 proteins

```{r}
# load("../Data/masstagSCE.rda")
# cd45.sce # 38 * 426872 
# rm(epith.sce, livecells.sce, myeloid.sce, tcell.sce)

```

Drop the five subjects without any clinical data. We can use Gender variable to identify those subjects
```{r}
# unique(colData(cd45.sce)$patient_id.y[which(is.na(colData(cd45.sce)$Gender))])

# cd45_to_keep <- which(!is.na(colData(cd45.sce)$Gender))
# cd45.sce_dropna <- cd45.sce[,cd45_to_keep]
# cd45.sce_dropna # 38 * 420685
# # To verify there are no (true) NA's left:
# sum(is.na(rowData(cd45.sce_dropna)))
# rm(cd45.sce, cd45_to_keep)
```


```{r}
#saveRDS(cd45.sce_dropna, "../Data/cd45_sce_dropna.rds")
cd45_sce_dropna <- readRDS("../Data/cd45_sce_dropna.rds")
cd45_sce_dropna
```

There are three proteins without gene symbol in cd45_sce_dropna so we drop them
```{r}
Proteins_in_cd45 <- !(rowData(cd45_sce_dropna)$hgnc_symbol == "na")

cd45_sce_dropna <- cd45_sce_dropna[which(Proteins_in_cd45),]
cd45_sce_dropna
```

There are two different health status 
```{r}
table(colData(cd45_sce_dropna)$Health.Status)

```

There are 6 different clinical subtypes, including TN and healthy 
```{r}
table(colData(cd45_sce_dropna)$Clinical.Subtype)
```

Subset TN clinical subtype
```{r}
cd45_sce_dropna <- cd45_sce_dropna[, colData(cd45_sce_dropna)$Clinical.Subtype == "TN"]
cd45_sce_dropna
#drop cells(columns) with no protein expression
cd45_sce_dropna <- cd45_sce_dropna[, colSums(assay(cd45_sce_dropna)) > 0]
cd45_sce_dropna
# drop levels of patient_id.x
colData(cd45_sce_dropna)$patient_id.x <- droplevels(colData(cd45_sce_dropna)$patient_id.x)
```

There are six TN patients and two had previous cancer incidence
```{r}
table(colData(cd45_sce_dropna)$Previous.Cancer.Incidences, colData(cd45_sce_dropna)$patient_id.x)
```


Let us see the 38 protein expression in 1000 randomly slected cells (TN Clinical subtypes)
```{r}
or <- order(rowMeans(assay(cd45_sce_dropna)),
            decreasing=TRUE)
colData(cd45_sce_dropna)$cell_id <- paste0("cell_", seq(1, dim(cd45_sce_dropna)[2]))
colnames(cd45_sce_dropna) <- colData(cd45_sce_dropna)$cell_id


g <- cd45_sce_dropna$patient_id.x
choose_by_patient <- split(colData(cd45_sce_dropna)%>% data.frame, g)
choose_by_patient_cells <- lapply(choose_by_patient, function(x){
  sample_cell_ids <- sample(x$cell_id, 100)
  
  return(sample_cell_ids)
  
}) %>% unlist()
names(choose_by_patient_cells) <- NULL

# ass <- assay(cd45_sce_dropna)[or, sample(1:dim(cd45_sce_dropna)[2], 1000)]
ass <- assay(cd45_sce_dropna)[or, which(cd45_sce_dropna$cell_id %in%  choose_by_patient_cells)]

df <- as.data.frame(colData(cd45_sce_dropna)[colnames(ass), c("patient_id.x", "Menopause.Status", "Previous.Cancer.Incidences", "HER2.IHC.Score" ,"cell_id")])

df <- with(df, df[order(patient_id.x, Menopause.Status, Previous.Cancer.Incidences, HER2.IHC.Score, cell_id),])
ass <- ass[, df$cell_id]
df <- dplyr::select(df, -cell_id)

rownames(ass) <- rowData(cd45_sce_dropna)$marker_name[or]

p <- pheatmap(ass, 
              annotation_col = df, 
              cluster_rows = FALSE, 
              cluster_cols = FALSE, 
              fontsize_row = 14, 
              fontsize_col = 14, 
              show_colnames = FALSE)

ggsave("../Figures/cytof.png", p , width = 12, height = 10)

```


# Keren et al., MIBI-TOF Breast Cancer Data 


- All the patients were 39 TN patients
- The size-normalized raw intensity values are then arcsinh transformed and standardized across the markers. 

```{r}
load('../Data/mibiSCE.rda')
mibi.sce

rowMeans(assay(mibi.sce))
rowSds(assay(mibi.sce))
```

Rows correspond to channels and columns correspond to cells.
We can see all of the channels that were collected in this experiment:

```{r}
rownames(mibi.sce)
```



The 38 proteins can be easily identified by using the binary attribute is_protein from rowData:

```{r}
mibi.sce_proteins <- mibi.sce[rowData(mibi.sce)$is_protein == 1,]
mibi.sce_proteins
rm(mibi.sce)
```


Cell type information is availble in the columns *tumor_group* and *immune_group* . That is, 51% of cells were Keratin positive tumor cells and 41% of cells were immune cells.

```{r}
round(table(mibi.sce_proteins$tumor_group)/ncol(mibi.sce_proteins),2)
```


Among the immune cells, macrophages and CD8, CD4+ T-cells and other immune cells were identified.  10% of all cells assayed were macrophages

```{r}
# Immune Cells
round(table(mibi.sce_proteins$immune_group)/ncol(mibi.sce_proteins),2)
```

Consider Keratin positive tumor cells and immune cells (there are different immune cell types within immune cells)
```{r}
table(colData(mibi.sce_proteins)$tumor_group)
table(colData(mibi.sce_proteins)$tumor_group, colData(mibi.sce_proteins)$immune_group)

mibi.sce_proteins <- mibi.sce_proteins[, colData(mibi.sce_proteins)$tumor_group %in% c("Immune", "Keratin-positive tumor")]
```



heatmap of protein expression in tumor and immune cells 
```{r}
# colData(mibi.sce_proteins)$DONOR_NO <- colData(mibi.sce_proteins)$DONOR_NO %>% as.character()
# mibi <- mibi.sce_proteins[, colData(mibi.sce_proteins)$DONOR_NO %in% "30838"]
mibi <- mibi.sce_proteins
mibi
#drop cells(columns) with no protein expression
mibi <- mibi[, colSums(assay(mibi)) > 0]
mibi
#drop proteins(rows) with no expression in any of these cells
mibi <- mibi[rowSums(assay(mibi)) > 0, ]
mibi
```

The issue in the normalization is that expressions are standardized across protein markers and there are some outliers.

Can we remove outliers after transformation?
```{r}
summary(as.vector(assay(mibi)))

hist(as.vector(assay(mibi)), breaks = 100)

# remove cells with outlier expression
rm_outliers <- apply(assay(mibi), 2, function(x){ sum(abs(x) > 5) >= 1 })
mibi <- mibi[, which(!rm_outliers)]
mibi
```

rowData(mibi) doesn't have cell IDs, so we add it.
```{r}
colData(mibi)$cell_id <- paste0("mibi_", seq(1, dim(mibi)[2]))
colnames(mibi) <- colData(mibi)$cell_id
colData(mibi)$DONOR_NO <- colData(mibi)$DONOR_NO %>% as.character()
```


# heatmap 
```{r}
or <- order(rowMeans(assay(mibi)),
            decreasing=TRUE)

g <- mibi$DONOR_NO %>% factor()
choose_by_patient <- split(colData(mibi)%>% data.frame, g)
sample_by_patient <- sample(seq(1, length(choose_by_patient)), 5)


no_cells_per_patient <- table(mibi$DONOR_NO) %>% data.frame()
no_cells_per_patient <- data.frame(no_cells_per_patient$Freq)
no_cells_sample <- apply(no_cells_per_patient, 1, function(y){
  min(50, y)
})

patient_list <- as.list(seq(1, length(choose_by_patient)))
  
choose_by_patient_cells <- lapply(patient_list, function(x){
  sample_cell_ids <- sample(choose_by_patient[[x]]$cell_id, no_cells_sample[x])

  return(sample_cell_ids)

}) 
choose_by_patient_cells <- choose_by_patient_cells[sample_by_patient]

choose_by_patient_cells <- choose_by_patient_cells %>% unlist()
names(choose_by_patient_cells) <- NULL

# ass <- assay(mibi)[or, sample(1:dim(mibi)[2], 1000)]
ass <- assay(mibi)[or, which(mibi$cell_id %in%  choose_by_patient_cells)]


df <- as.data.frame(colData(mibi)[colnames(ass), c("DONOR_NO", "tumor_group", "immune_group","cell_id")])

df <- with(df, df[order(DONOR_NO, tumor_group, immune_group,cell_id), ])
ass <- ass[, df$cell_id]
df <- dplyr::select(df, -cell_id)

rownames(ass) <- rownames(rowData(mibi))[or]

p <- pheatmap(ass, 
              annotation_col = df, 
              cluster_rows = FALSE, 
              cluster_cols = FALSE, 
              fontsize_row = 14, 
              fontsize_col = 14, 
              show_colnames = FALSE)

ggsave("../Figures/mibi_tof.png", p , width = 12, height = 10)

```


# UMAP

```{r}
cell_type <- ifelse(mibi$immune_group != "not immune", mibi$immune_group, "Tumor")
mibi$cell_type <- cell_type
  
```

We use the default settings  (expect to result in disconnected components) 
```{r}
mibi_umap <- umap(assay(mibi) %>% t())
umap_df <- data.frame(UMAP1 = mibi_umap[,1], 
                      UMAP2 = mibi_umap[,2], 
                      cell_id = colData(mibi)$cell_id)
mibi_cell_data <- colData(mibi) %>% data.frame()
umap_df  <- left_join(umap_df, mibi_cell_data, by = "cell_id")

manual_col <- tableau_color_pal("Classic 20")(length(unique(mibi$cell_type)))

ggplot(data = umap_df, 
       aes(x = UMAP1, y = UMAP2, color = cell_type)) + 
  geom_point() +
  theme_bw() +
  scale_color_manual(values = manual_col) +
  theme(aspect.ratio = 1) +
  labs(color = "Cell types")
```

Some machropages, CD4, CD8 immune cells make clusters with tumor cells.

Let's change the nearest neighbors to 50
```{r}
mibi_umap <- umap(assay(mibi) %>% t(), n_neighbors = 50)
umap_df <- data.frame(UMAP1 = mibi_umap[,1], 
                      UMAP2 = mibi_umap[,2], 
                      cell_id = colData(mibi)$cell_id)
mibi_cell_data <- colData(mibi) %>% data.frame()
umap_df  <- left_join(umap_df, mibi_cell_data, by = "cell_id")


ggplot(data = umap_df, 
       aes(x = UMAP1, y = UMAP2, color = cell_type)) + 
  geom_point() +
  theme_bw() +
  scale_color_manual(values = manual_col) +
  theme(aspect.ratio = 1) +
  labs(color = "Cell types")
```

There is no difference in clusters of points if we change n_neighbors to 50.

# PCA

```{r}
ass <- t(assay(mibi))

pc <- ade4::dudi.pca(ass, scannf = FALSE, nf=3)
df <- data.frame(pc$l1, colData(mibi))
p <- ggplot(data = df) +
  geom_point(aes(x = RS1,
                      y = RS2, 
                      col = cell_type)) + 
  xlab(paste0("PC1: ",round(pc$eig[1]/sum(pc$eig)*100, digits = 1),"% variance")) +
  ylab(paste0("PC2: ",round(pc$eig[2]/sum(pc$eig)*100, digits = 1),"% variance")) + 
  coord_fixed(sqrt(pc$eig[2]/pc$eig[1])) +
  theme_bw() +
  scale_color_manual(values = manual_col) 

p
```

Though macrophages are closer to tumor cells, PCA seems to make clusters in the order of number of points in each cluster: Tumor > Macrophages > ...

```{r}
table(mibi$cell_type)
```




# adding spatial coordinates to mibi
```{r eval=FALSE}
library(raster)
IMG <- '../Data/TNBC_shareCellData/p2_labeledcellData.tiff'
ras_obj <- raster(IMG)
ras_obj
plot(ras_obj, main = strsplit(IMG,'/')[[1]][4])

#cell labels
ras_obj[1500:1510,1500:1510]
space_mat <- as.matrix(ras_obj)
space_mat[1510:1530,1510:1530]

```


```{r}
manual_col_sample_id <- tableau_color_pal("Classic 20")(length(unique(mibi$cell_type)))
manual_col_sample_id <- c(manual_col_sample_id, "black")
names(manual_col_sample_id) <- c(unique(mibi$cell_type), "Background")
```


```{r}
tiff_file_list <- list.files("../Data/TNBC_shareCellData/", pattern = ".tiff")

id <- 2

str_name <- paste("../Data/TNBC_shareCellData/", tiff_file_list[id], sep = "")

sample_id <- as.numeric(gsub("p", "", gsub("_labeledcellData.tiff", "", tiff_file_list[id])))
sample_id

r <- raster(str_name)
r

mibi_sample_id <- mibi[, mibi$SampleID == sample_id]

df_rP <- rasterToPoints(r)
df_rP <- data.frame(df_rP)
colnames(df_rP) <- c("X", "Y", "values")


noise_not_in_mibi <- unique(df_rP$values[!df_rP$values %in% mibi_sample_id$cellLabelInImage])
# match cell lable that is not in mibi but in the image to Background
cell_label_with_bg <- mapvalues((df_rP$values), 
                                from = noise_not_in_mibi, 
                                to = rep("Background", length(noise_not_in_mibi)))
cell_label_with_bg <- mapvalues((cell_label_with_bg), 
                                from = mibi_sample_id$cellLabelInImage, 
                                to = mibi_sample_id$cell_type)

df_rP$cell_label_with_bg <- cell_label_with_bg
df_rP$cell_label_with_bg <- factor(df_rP$cell_label_with_bg)
df_rP$cell_label_with_bg <- factor(df_rP$cell_label_with_bg, levels = c(levels(df_rP$cell_label_with_bg)[-which(levels(df_rP$cell_label_with_bg) == "Background")], "Background"))


# manual_col_sample_id <- tableau_color_pal("Classic 20")(length(unique(df_rP$cell_label_with_bg))-1)
# manual_col_sample_id <- c(manual_col_sample_id, "black")


ggplot(NULL) + 
  geom_raster(data = df_rP, 
              aes(X, Y, fill = cell_label_with_bg)) +
  theme_minimal() +
  scale_fill_manual(values = manual_col_sample_id) +
  coord_quickmap() +
  theme(aspect.ratio = 1, legend.position = "right") +
  labs(fill = "Cell types")


```


```{r}
tiff_file_list <- list.files("../Data/TNBC_shareCellData/", pattern = ".tiff")

id <- 3

str_name <- paste("../Data/TNBC_shareCellData/", tiff_file_list[id], sep = "")

sample_id <- as.numeric(gsub("p", "", gsub("_labeledcellData.tiff", "", tiff_file_list[id])))
sample_id

r <- raster(str_name)
r

mibi_sample_id <- mibi[, mibi$SampleID == sample_id]

df_rP <- rasterToPoints(r)
df_rP <- data.frame(df_rP)
colnames(df_rP) <- c("X", "Y", "values")


noise_not_in_mibi <- unique(df_rP$values[!df_rP$values %in% mibi_sample_id$cellLabelInImage])
# match cell lable that is not in mibi but in the image to Background
cell_label_with_bg <- mapvalues((df_rP$values), 
                                from = noise_not_in_mibi, 
                                to = rep("Background", length(noise_not_in_mibi)))
cell_label_with_bg <- mapvalues((cell_label_with_bg), 
                                from = mibi_sample_id$cellLabelInImage, 
                                to = mibi_sample_id$cell_type)

df_rP$cell_label_with_bg <- cell_label_with_bg
df_rP$cell_label_with_bg <- factor(df_rP$cell_label_with_bg)
df_rP$cell_label_with_bg <- factor(df_rP$cell_label_with_bg, levels = c(levels(df_rP$cell_label_with_bg)[-which(levels(df_rP$cell_label_with_bg) == "Background")], "Background"))


# manual_col_sample_id <- tableau_color_pal("Classic 20")(length(unique(df_rP$cell_label_with_bg))-1)
# manual_col_sample_id <- c(manual_col_sample_id, "black")


ggplot(NULL) + 
  geom_raster(data = df_rP, 
              aes(X, Y, fill = cell_label_with_bg)) +
  theme_minimal() +
  scale_fill_manual(values = manual_col_sample_id) +
  coord_quickmap() +
  theme(aspect.ratio = 1, legend.position = "right") +
  labs(fill = "Cell types")
```


```{r}

tiff_file_list <- list.files("../Data/TNBC_shareCellData/", pattern = ".tiff")

id <- 3

str_name <- paste("../Data/TNBC_shareCellData/", tiff_file_list[id], sep = "")

sample_id <- as.numeric(gsub("p", "", gsub("_labeledcellData.tiff", "", tiff_file_list[id])))
sample_id

r <- raster(str_name)
r

mibi_sample_id <- mibi[, mibi$SampleID == sample_id]

df_rP <- rasterToPoints(r)
df_rP <- data.frame(df_rP)
colnames(df_rP) <- c("X", "Y", "values")
noise_not_in_mibi <- unique(df_rP$values[!df_rP$values %in% mibi_sample_id$cellLabelInImage])

# compute centroid of each cell
centroid_X <- aggregate(df_rP[,1], by = list(df_rP[,3]), FUN = median)
centroid_Y <- aggregate(df_rP[,2], by = list(df_rP[,3]), FUN = median)
centroid_XY <- data.frame(centroid_X = centroid_X$x, centroid_Y = centroid_Y$x, group = centroid_X$Group.1)
cell_label_with_bg_XY <- mapvalues((centroid_XY$group), from = noise_not_in_mibi, to = rep(0, length(noise_not_in_mibi)))
cell_label_with_bg_XY <- mapvalues((cell_label_with_bg_XY), from = mibi_sample_id$cellLabelInImage, to = mibi_sample_id$cell_type)
centroid_XY$cell_label_with_bg_XY <- cell_label_with_bg_XY

# filter the center info without cells 
centroid_XY <- centroid_XY[centroid_XY$cell_label_with_bg_XY != "0", ]


dd_sample_id <- colData(mibi_sample_id) %>% data.frame()
dd_sample_id <- left_join(dd_sample_id, centroid_XY, by = c("cellLabelInImage" = "group"))
mibi_sample_id$centroid_X <- dd_sample_id$centroid_X
mibi_sample_id$centroid_Y <- dd_sample_id$centroid_Y

saveRDS(mibi_sample_id, file = paste0("../Results/mibi_sample_id_", id, ".rds"))
```


# Variogram
```{r}

or <- order(rowMeans(assay(mibi_sample_id)),
            decreasing=TRUE)
marker_names <- rownames(mibi_sample_id)
df <- assay(mibi_sample_id) %>% t() %>% data.frame()
df$cell_id <- rownames(df)
cell_df <- colData(mibi_sample_id) %>% data.frame()
df <- left_join(cell_df, df, by = "cell_id") %>% data.frame()
# plot(df$centroid_X, df$centroid_Y)
coordinates(df) <- c("centroid_X", "centroid_Y")
bubble(df, zcol= marker_names[or[1]], fill=TRUE, do.sqrt=FALSE)

CD16_variogram <- variogram(CD16 ~ cell_type, data = df)
plot(CD16_variogram)
plot(CD16_variogram, cutoff=90)

#directional variogram
CD16_variogram_dir <- variogram(CD16 ~ 1,  data=df,  alpha=c(0,45,90,135))
plot(CD16_variogram_dir)
```


<!-- example of a smeivariogram -->

<!-- ```{r} -->
<!-- data(meuse) -->
<!-- plot(meuse$x, meuse$y) -->
<!-- #bubble chart to plot the zinc values -->
<!-- coordinates(meuse) <- c("x", "y") -->
<!-- bubble(meuse, zcol='zinc', fill=TRUE, do.sqrt=FALSE) -->

<!-- zin_variogram <- variogram(zinc~1, data=meuse) -->
<!-- plot(zin_variogram) -->

<!-- # we need to set sill, nudget, and range -->
<!-- #sill :maximum variance -->
<!-- #nugget: Theoretically, at zero separation distance (lag = 0), the semivariogram value is 0. However, at an infinitesimally small separation distance, the semivariogram often exhibits a nugget effect, which is some value greater than 0 -->
<!-- #range: The distance h at which the unbiased estimate $\gamma(h)$ reaches the sill is called the range -->
<!-- zin_variogram_model <- vgm(psill=150000, model="Sph", nugget=40000, range=1500)# model="Gau", "Exp", "Sph", "Mat" -->

<!-- plot(zin_variogram, model= zin_variogram_model) -->

<!-- # directional variogram -->
<!-- zinc_dir_var <- variogram(zinc~1,  data=meuse,  alpha=c(0,45,90,135)) -->
<!-- plot(zinc_dir_var) -->
<!-- ``` -->






